/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.example.comp3111_project.Algorithms;

//import java.lang.Math;   // ########## Should be taken away
import com.example.comp3111_project.HelloApplication;
import java.io.*;
import java.util.*;
import com.opencsv.CSVWriter;
import com.opencsv.CSVReader;

//@SuppressWarnings("unused")
public class TeamingProcess {

	private static int team_size = 3;
	private static int student_no = 100;
	private static int team_no;
	private static int remaining_student_no;
	public static double k1_mean;
	public static double k2_mean;
	
	
	// Can be taken away if not necessary
	public static void updateMeans(Person students[], int n) {
		int k1_sum = 0;
		int k2_sum = 0;
		
		for (int i = 0; i < n; i++) {
			k1_sum += Integer.parseInt(students[i].getK1energy());
			k2_sum += Integer.parseInt(students[i].getK2energy());
		}
		
		k1_mean = k1_sum / n;
		k2_mean = k2_sum / n;
	}
	
	public static double totalMeanDeviation(Team team, Person student) {
		double new_team_k1_avg = (team.getK1() * team.getPersonNo() + Integer.parseInt(student.getK1energy())) / (team.getPersonNo()+1);
		double new_team_k2_avg = (team.getK2() * team.getPersonNo() + Integer.parseInt(student.getK2energy())) / (team.getPersonNo()+1);
		double k1_deviation = new_team_k1_avg - k1_mean;
		double k2_deviation = new_team_k2_avg - k2_mean;
		
		//if (k1_deviation < 0) k1_deviation = 0 - k1_deviation;
		//if (k2_deviation < 0) k2_deviation = 0 - k2_deviation;
		// ** NOTE: The 2 statements above (abs val) are replaced by the following 2 statements (squaring) ** //
		k1_deviation *= k1_deviation; // k1_deviation ^ 2
		k2_deviation *= k2_deviation; // k2_deviation ^ 2
		
		return (k1_deviation + k2_deviation);
	}
	
	
	// subject means the variable being sorted in the preference list
	public static void sortTeamPreferenceList(Team team, SortingEntity subject[], int n) {
		for (int i = 0; i < n; i++) {
			subject[i].setTeam(team);
			subject[i].setData( totalMeanDeviation(team, subject[i].getPerson()) );
		}
		MergeSort.sort(subject, 0, n-1, true);
	}
	
	public static void sortStudentPreferenceList(Person student, SortingEntity subject[], int n) {
		for (int i = 0; i < n; i++) {
			subject[i].setPerson(student);
			subject[i].setData( totalMeanDeviation(subject[i].getTeam(), student) );
		}
		MergeSort.sort(subject, 0, n-1, true);
	}
	
	public static void form2dPreferenceList(SortingEntity preferenceLists[][], Team teams[], SortingEntity students[], 
										int longestListLength) {
		// Note: pL[0..team_no-1][] is for Team's preference lists
		//       pL[remaining_student_no..2*remaining_student_no-1][] is for Person's preference lists
		for (int i = 0; i < team_no; i++) {
			for (int j = 0; j < remaining_student_no; j++) {
				preferenceLists[i][j] = new SortingEntity(students[j]);
			}
			sortTeamPreferenceList(teams[i], preferenceLists[i], remaining_student_no);
		}
		for (int i = 0; i < remaining_student_no; i++) {
			for (int j = 0; j < team_no; j++) {
				preferenceLists[longestListLength+i][j] = new SortingEntity(teams[j]);
				preferenceLists[longestListLength+i][j].setIndex(j);
			}
			sortStudentPreferenceList(students[i].getPerson(), preferenceLists[longestListLength+i], team_no);
		}
	}
	
	public static void writeToCSVFile(String filePath, Team teams[])
	{
	    File file = new File(filePath);
	    try {
	        FileWriter outputfile = new FileWriter(file);
	        CSVWriter writer = new CSVWriter(outputfile, ',',
                    						 CSVWriter.NO_QUOTE_CHARACTER,
                    						 CSVWriter.DEFAULT_ESCAPE_CHARACTER,
                    						 CSVWriter.DEFAULT_LINE_END);
	  
	        // Add header to csv
	        String[] header = { "Team Id", "Student_id", "Student_name", "Team-mate 1", "Team-mate 2", 
	        					"Team-mate 3", "K1_average", "K2_average" };
	        writer.writeNext(header);
	        // Add data to csv
	        for (int k = 0; k < team_no; k++) {
	        	if (teams[k].getPersonNo() == 3) {
	        		for (int i = 0; i < 3; i++) {
	        			String[] rowdata = new String[8];
	        			rowdata[0] = ""+teams[k].getID();
	        			rowdata[1] = teams[k].getPersonAt(i).getStudentid();
	        			rowdata[2] = teams[k].getPersonAt(i).getStudentname();
	        			for (int j = 3; j < 5; j++) {
	        				rowdata[j] = teams[k].getPersonAt((i+j-2)%3).getStudentname();
	        			}
	        			rowdata[5] = "";
	        			rowdata[6] = ""+teams[k].getK1();
	        			rowdata[7] = ""+teams[k].getK2();
	        	        writer.writeNext(rowdata);
	        		}
	        	} else if (teams[k].getPersonNo() == 4) {
	        		for (int i = 0; i < 4; i++) {
	        			String[] rowdata = new String[8];
	        			rowdata[0] = ""+teams[k].getID();
	        			rowdata[1] = teams[k].getPersonAt(i).getStudentid();
	        			rowdata[2] = teams[k].getPersonAt(i).getStudentname();
	        			for (int j = 3; j < 6; j++) {
	        				rowdata[j] = teams[k].getPersonAt((i+j-2)%4).getStudentname();
	        			}
	        			rowdata[6] = ""+teams[k].getK1();
	        			rowdata[7] = ""+teams[k].getK2();
	        	        writer.writeNext(rowdata);
	        		}
	        	}
	        }
	  
	        writer.close();
	    } catch (IOException e) {
	        e.printStackTrace();
	    }
	}
	
	
	
	// NOTES: 1. Array is passed by value in java
	//		  2. Array is copied by reference in java
	//        3. Object is copied by reference in java
	public static void main(String args[]) {
		// Get Students(i.e. Person) from HelloApplication.java
		HelloApplication inputTask = new HelloApplication();
		List<Person> student_list = inputTask.getPerson_data().getItems(); 	// observable list --> list
		
		student_no = student_list.size();
		
		Person students[] = new Person[student_no];
        for (int i = 0; i < student_no; i++)
        	students[i] = student_list.get(i);			// list to array
		
		/*// Create Students
		Person students[] = new Person[student_no];
		for (int i = 0; i < student_no; i++) {
			String stu_id = "" + i;
			int k1 = (int)(Math.random()*(100+1));  
			int k2 = (int)(Math.random()*(100+1));  
			students[i] = new Person(stu_id, "", "", k1+"", k2+"", "", "", "", "");
		}*/
		
		
		// PART I ---------- 
		// Calculate k1_mean & k2_mean
		updateMeans(students, student_no);
		//System.out.println("k1_mean = " + k1_mean); // ########## TESTING
		//System.out.println("k2_mean = " + k2_mean); // ########## TESTING
		
		// Create SortingEntity of Person for sorting according to their K1
		SortingEntity k1SortedStudents[] = new SortingEntity[student_no];
		for (int i = 0; i < student_no; i++) {
			k1SortedStudents[i] = new SortingEntity(students[i]);
			k1SortedStudents[i].setData( Integer.parseInt(students[i].getK1energy()) );
			k1SortedStudents[i].setIndex(i);
			// here, automatic conversion from int to double occurs 
		}
		
		// Sort the students using merge sort according to their k1_energies
		MergeSort.sort(k1SortedStudents, 0, student_no-1, false);
		
		
		// Create teams for first student_no/3 students + Add 1st student to Team
		team_no = student_no / team_size;
		Team teams[] = new Team[team_no];
		for (int i = 0; i < team_no; i++) {
			teams[i] = new Team(i+1, k1SortedStudents[i].getPerson());
			k1SortedStudents[i].setIndex(-1);
		}
		
		
		// PART II ---------- 
		remaining_student_no = student_no - team_no;
		SortingEntity sortedStudents2ndR[] = new SortingEntity[remaining_student_no];
		for (int i = 0; i < remaining_student_no; i++) {
			sortedStudents2ndR[i] = k1SortedStudents[team_no+i]; // Note: copy by reference
			sortedStudents2ndR[i].setIndex(i);
		}
		
		// Form preference lists for teams and remaining students (2nd team mate)
		SortingEntity preferenceLists2nd[][] = new SortingEntity[2*remaining_student_no][remaining_student_no];
		// Note: pL[0..team_no-1][] is for Team's preference lists
		//       pL[remaining_student_no..2*remaining_student_no-1][] is for Person's preference lists
		form2dPreferenceList(preferenceLists2nd, teams, sortedStudents2ndR, remaining_student_no);
		
		// Matching for 2nd team mate
		GSAlgorithm.setNumbers(team_no, remaining_student_no, remaining_student_no);
		GSAlgorithm.GS_Matching(preferenceLists2nd, teams, sortedStudents2ndR);
		
		
		// PART III ---------- 
		remaining_student_no -= team_no;
		SortingEntity sortedStudents3rdR[] = new SortingEntity[remaining_student_no];
		for (int i = 0, j = 0; j < remaining_student_no+team_no; j++) {
			if (sortedStudents2ndR[j].getIndex() != -1) {
				sortedStudents3rdR[i] = sortedStudents2ndR[j]; // Note: copy by reference
				sortedStudents3rdR[i].setIndex(i);
				i++;
			}
		}
		
		// Form preference lists for teams and remaining students (3rd team mate)
		SortingEntity preferenceLists3rd[][] = new SortingEntity[2*remaining_student_no][remaining_student_no];
		// Note: pL[0..team_no-1][] is for Team's preference lists
		//       pL[remaining_student_no..2*remaining_student_no-1][] is for Person's preference lists
		form2dPreferenceList(preferenceLists3rd, teams, sortedStudents3rdR, remaining_student_no);
		
		// Matching for 3rd team mate
		GSAlgorithm.setNumbers(team_no, remaining_student_no, remaining_student_no);
		GSAlgorithm.GS_Matching(preferenceLists3rd, teams, sortedStudents3rdR);
		
		
		// PART IV ---------- 
		// Check if there is still remaining students
		remaining_student_no -= team_no;
		if (remaining_student_no != 0) {
			// If not 0, repeat previous process one more time ... 
			SortingEntity remainingStudents[] = new SortingEntity[remaining_student_no];
			for (int i = 0, j = 0; j < remaining_student_no+team_no; j++) {
				if (sortedStudents3rdR[j].getIndex() != -1) {
					remainingStudents[i] = sortedStudents3rdR[j]; // Note: copy by reference
					remainingStudents[i].setIndex(i);
					i++;
				}
			}

			// Form preference lists for teams and remaining students (remaining student)
			//SortingEntity preferenceListsremain[][] = new SortingEntity[2*team_no][team_no];
			//form2dPreferenceList(preferenceListsremain, teams, remainingStudents, team_no);
			// Do the last matching ... 
			//GSAlgorithm.setNumbers(team_no, remaining_student_no, team_no);
			//GSAlgorithm.GS_Matching(preferenceListsremain, teams, remainingStudents);
			
			//*// Assign remaining students according to team order
			for (int k = 0; k < remainingStudents.length; k++) {
				teams[k].addStudent(remainingStudents[k].getPerson());
			}//*/
		}
		
		// Note: Team data are stored in teams[] ; Person data are stored in students[]
		
		// Create a dataset for team assignment 
		writeToCSVFile("./result.csv", teams);
		
		/*// ########## The following statements are for testing purpose, should be taken away
		System.out.println("==================================================");
		System.out.println("Group Assignment Result: ");
		for (int x = 0; x < teams.length; x++) {
			for (int y = 0; y < teams[x].getPersonNo(); y++) {
				System.out.print(teams[x].getPersonAt(y).getStudentid() + "\t");
			}
			System.out.print("\t\t k1 average = " + teams[x].getK1() + " ; k2 average = " + teams[x].getK2());
			System.out.print("\n");
		}*/
		
	}
}
