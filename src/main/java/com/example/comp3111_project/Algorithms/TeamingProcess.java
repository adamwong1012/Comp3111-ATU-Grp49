/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.example.comp3111_project.Algorithms;

import com.example.comp3111_project.HelloApplication;
import javafx.collections.ObservableList;

import java.lang.Math;   // ########## Should be taken away

//@SuppressWarnings("unused")
public class TeamingProcess {

	private static int team_size = 3;
	private static int student_no = 125;
	private static int team_no;
	private static int remaining_student_no;
	public static double k1_mean;
	public static double k2_mean;

	private Team[] teams;
	
	
	/**
	 * updateMeans(..) method calculates the k1 mean and k2 mean of all students
	 * @param students[] an array of Person for students, students[]
	 * @param n an integer indicating the number of students
	 * @return none
	 */
	public static void updateMeans(Person students[], int n) {
		int k1_sum = 0;
		int k2_sum = 0;
		
		for (int i = 0; i < n; i++) {
			k1_sum += Integer.parseInt(students[i].getK1energy());
			k2_sum += Integer.parseInt(students[i].getK2energy());
		}
		
		k1_mean = k1_sum / n;
		k2_mean = k2_sum / n;
	}
	
	/**
	 * totalMeanDeviation(..) method calculates the deviation of a team from the global mean
	 * after adding the student into the team
	 * @param a Team object, team
	 * @param a Person object, students
	 * @return the sum of the deviation of k1 and k2 energies
	 */
	public static double totalMeanDeviation(Team team, Person student) {
		double new_team_k1_avg = (team.getK1() * team.getPersonNo() + Integer.parseInt(student.getK1energy())) / (team.getPersonNo()+1);
		double new_team_k2_avg = (team.getK2() * team.getPersonNo() + Integer.parseInt(student.getK2energy())) / (team.getPersonNo()+1);
		double k1_deviation = new_team_k1_avg - k1_mean;
		double k2_deviation = new_team_k2_avg - k2_mean;
		
		//if (k1_deviation < 0) k1_deviation = 0 - k1_deviation;
		//if (k2_deviation < 0) k2_deviation = 0 - k2_deviation;
		// ** NOTE: The 2 statements above (abs val) are replaced by the following 2 statements (squaring) ** //
		k1_deviation *= k1_deviation; // k1_deviation ^ 2
		k2_deviation *= k2_deviation; // k2_deviation ^ 2
		
		return (k1_deviation + k2_deviation);
	}
	
	
	/**
	 * sortTeamPreferenceList(..) method generates a preference list of students for a team
	 * @param a Team object, team
	 * @param an array of SortingEntity objects, subject[], storing information of students
	 * @param an integer indicating the number of students
	 * @return none
	 */
	// subject means the variable being sorted in the preference list
	public static void sortTeamPreferenceList(Team team, SortingEntity subject[], int n) {
		for (int i = 0; i < n; i++) {
			subject[i].setTeam(team);
			subject[i].setData( totalMeanDeviation(team, subject[i].getPerson()) );
		}
		MergeSort.sort(subject, 0, n-1, true);
	}
	
	/**
	 * sortStudentPreferenceList(..) method generates a preference list of teams for a student
	 * @param a Person object, student
	 * @param an array of SortingEntity objects, subject[], storing information of teams
	 * @param an integer indicating the number of teams
	 * @return none
	 */
	public static void sortStudentPreferenceList(Person student, SortingEntity subject[], int n) {
		for (int i = 0; i < n; i++) {
			subject[i].setPerson(student);
			subject[i].setData( totalMeanDeviation(subject[i].getTeam(), student) );
		}
		MergeSort.sort(subject, 0, n-1, true);
	}
	
	/**
	 * form2dPreferenceList(..) method generates a 2d preference using sortTeamPreferenceList(..)
	 * and sortStudentPreferenceList(..)
	 * @param a 2d SortingEntity object array, preferenceLists[][], storing the preferences for
	 *        teams or students for each student and team respectively
	 * @param an arrry of Team objects, teams[], storing information of students
	 * @param an array of SortingEntity objects, subject[], storing information of teams
	 * @param an integer defining the dimension of preferenceLists, longestListLength
	 * @return none
	 */
	public static void form2dPreferenceList(SortingEntity preferenceLists[][], Team teams[], SortingEntity students[], 
										int longestListLength) {
		// Note: pL[0..team_no-1][] is for Team's preference lists
		//       pL[remaining_student_no..2*remaining_student_no-1][] is for Person's preference lists
		for (int i = 0; i < team_no; i++) {
			for (int j = 0; j < remaining_student_no; j++) {
				preferenceLists[i][j] = new SortingEntity(students[j]);
			}
			sortTeamPreferenceList(teams[i], preferenceLists[i], remaining_student_no);
		}
		for (int i = 0; i < remaining_student_no; i++) {
			for (int j = 0; j < team_no; j++) {
				preferenceLists[longestListLength+i][j] = new SortingEntity(teams[j]);
				preferenceLists[longestListLength+i][j].setIndex(j);
			}
			sortStudentPreferenceList(students[i].getPerson(), preferenceLists[longestListLength+i], team_no);
		}
	}
	
	
	/**
	 * printE(..) method print the student id, k1 energy and k2 energy
	 * @param a sortingEntity array entity[]
	 * @return none
	 */
	public static void printE(SortingEntity entity[]) {
		for (int i = 0; i < entity.length; i++) {
			if (entity[i] != null) {
				System.out.print(entity[i].getPerson().getStudentid() + ", ");
				System.out.print(entity[i].getPerson().getK1energy() + ", ");
				System.out.print(entity[i].getPerson().getK2energy() + "\n");
			}
		}
	}
	
	
	// NOTES: 1. Array is passed by value in java
	//		  2. Array is copied by reference in java
	//        3. Object is copied by reference in java
	public TeamingProcess(ObservableList<HelloApplication.Person> args) {
		/******* The following few lines of code will be replaced */
		// Create Students
		Person students[] = new Person[args.size()];
		int count = 0;
		for (HelloApplication.Person person: args) {
			students[count] = new Person(person.getStudentid(),person.getStudentname(),person.getStudentemail(),person.getK1energy(),person.getK2energy(),person.getK3trick1(),person.getK3trick2(),person.getMypreference(),person.getConcerns());
			count++;
		}
		student_no = args.size();

		/* Replacing Ends */
		
		
		// PART I ---------- 
		// Calculate k1_mean & k2_mean
		updateMeans(students, student_no);
		System.out.println("Overall Statistics: ");
		System.out.println("k1_mean = " + k1_mean); // ########## TESTING
		System.out.println("k2_mean = " + k2_mean); // ########## TESTING
		
		// Create SortingEntity of Person for sorting according to their K1
		SortingEntity k1SortedStudents[] = new SortingEntity[student_no];
		for (int i = 0; i < student_no; i++) {
			k1SortedStudents[i] = new SortingEntity(students[i]);
			k1SortedStudents[i].setData( Integer.parseInt(students[i].getK1energy()) );
			k1SortedStudents[i].setIndex(i);
			// here, automatic conversion from int to double occurs 
		}
		
		// Sort the students using merge sort according to their k1_energies
		MergeSort.sort(k1SortedStudents, 0, student_no-1, false);

		System.out.println("==================================================");
		System.out.println("Students sorted according to their k1: "); // ########## TESTING 
		System.out.println("ID, K1, K2");
		printE(k1SortedStudents); 
		System.out.println();
		
		// Create teams for first student_no/3 students + Add 1st student to Team
		team_no = student_no / team_size;
		teams = new Team[team_no];
		for (int i = 0; i < team_no; i++) {
			teams[i] = new Team(i+1, k1SortedStudents[i].getPerson());
			k1SortedStudents[i].setIndex(-1);
		}
		
		
		// PART II ---------- 
		remaining_student_no = student_no - team_no;
		SortingEntity sortedStudents2ndR[] = new SortingEntity[remaining_student_no];
		for (int i = 0; i < remaining_student_no; i++) {
			sortedStudents2ndR[i] = k1SortedStudents[team_no+i]; // Note: copy by reference
			sortedStudents2ndR[i].setIndex(i);
		}
		
		// Form preference lists for teams and remaining students (2nd team mate)
		SortingEntity preferenceLists2nd[][] = new SortingEntity[2*remaining_student_no][remaining_student_no];
		// Note: pL[0..team_no-1][] is for Team's preference lists
		//       pL[remaining_student_no..2*remaining_student_no-1][] is for Person's preference lists
		form2dPreferenceList(preferenceLists2nd, teams, sortedStudents2ndR, remaining_student_no);
		
		// Matching for 2nd team mate
		GSAlgorithm.setNumbers(team_no, remaining_student_no, remaining_student_no);
		GSAlgorithm.GS_Matching(preferenceLists2nd, teams, sortedStudents2ndR);
		
		
		// PART III ---------- 
		remaining_student_no -= team_no;
		SortingEntity sortedStudents3rdR[] = new SortingEntity[remaining_student_no];
		for (int i = 0, j = 0; j < remaining_student_no+team_no; j++) {
			if (sortedStudents2ndR[j].getIndex() != -1) {
				sortedStudents3rdR[i] = sortedStudents2ndR[j]; // Note: copy by reference
				sortedStudents3rdR[i].setIndex(i);
				i++;
			}
		}
		
		// Form preference lists for teams and remaining students (3rd team mate)
		SortingEntity preferenceLists3rd[][] = new SortingEntity[2*remaining_student_no][remaining_student_no];
		// Note: pL[0..team_no-1][] is for Team's preference lists
		//       pL[remaining_student_no..2*remaining_student_no-1][] is for Person's preference lists
		form2dPreferenceList(preferenceLists3rd, teams, sortedStudents3rdR, remaining_student_no);
		
		// Matching for 3rd team mate
		GSAlgorithm.setNumbers(team_no, remaining_student_no, remaining_student_no);
		GSAlgorithm.GS_Matching(preferenceLists3rd, teams, sortedStudents3rdR);
		
		
		// PART IV ---------- 
		// Check if there is still remaining students
		remaining_student_no -= team_no;
		if (remaining_student_no != 0) {
			// If not 0, repeat previous process one more time ... 
			SortingEntity remainingStudents[] = new SortingEntity[remaining_student_no];
			for (int i = 0, j = 0; j < remaining_student_no+team_no; j++) {
				if (sortedStudents3rdR[j].getIndex() != -1) {
					remainingStudents[i] = sortedStudents3rdR[j]; // Note: copy by reference
					remainingStudents[i].setIndex(i);
					i++;
				}
			}

			// Form preference lists for teams and remaining students (remaining student)
			//SortingEntity preferenceListsremain[][] = new SortingEntity[2*team_no][team_no];
			//form2dPreferenceList(preferenceListsremain, teams, remainingStudents, team_no);
			// Do the last matching ... 
			//GSAlgorithm.setNumbers(team_no, remaining_student_no, team_no);
			//GSAlgorithm.GS_Matching(preferenceListsremain, teams, remainingStudents);
			
			//*// Assign remaining students according to team order
			for (int k = 0; k < remainingStudents.length; k++) {
				teams[k].addStudent(remainingStudents[k].getPerson());
			}//*/
		}
		
		// Note: Team data are stored in teams[] ; Person data are stored in students[]
		
		// ########## The following statements are for testing purpose, should be taken away
		System.out.println("==================================================");
		System.out.println("Group Assignment Result: ");
		System.out.println("Team ID" + "\t" + "Grp Mate 1" + "\t" + "Grp Mate 2" + "\t" + "Grp Mate 3" + "\t" + "Grp Mate 4 (if any)");
		for (int x = 0; x < teams.length; x++) {
			System.out.println(teams[x].getID() + "\t");
			for (int y = 0; y < teams[x].getPersonNo(); y++) {
				System.out.print(teams[x].getPersonAt(y).getStudentid() + "\t");
			}
			System.out.print("\t\t k1 average = " + teams[x].getK1() + " ; k2 average = " + teams[x].getK2());
			System.out.print("\n");
		}

		
	}
	public  Team[] getTeamArray() {
		return teams;
	}

}
